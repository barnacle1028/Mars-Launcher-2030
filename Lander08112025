<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mars Lander</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: linear-gradient(to bottom, #000 0%, #1a0505 100%);
      font-family: 'Courier New', monospace;
      color: white;
      height: 100vh;
      width: 100vw;
    }

    #gameCanvas {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1;
      background: transparent;
    }

    #startScreen, #gameOverScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, rgba(0,0,0,0.95) 0%, rgba(30,10,10,0.95) 100%);
      z-index: 10;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
    }

    h1 { font-size: 48px; margin-bottom: 10px; text-shadow: 0 0 20px rgba(255,100,0,0.5); }

    .instructions {
      margin: 20px;
      padding: 20px;
      background: rgba(0,0,0,0.5);
      border-radius: 10px;
      max-width: 420px;
      line-height: 1.6;
    }

    .controls { display: grid; grid-template-columns: auto auto; gap: 10px; margin-top: 10px; }
    .controls span:first-child { color: #ff9944; text-align: right; }

    button {
      font-size: 20px; padding: 12px 30px; margin-top: 20px; cursor: pointer;
      background: linear-gradient(135deg, #ff6600, #cc3300); color: white; border: none; border-radius: 5px;
      text-transform: uppercase; letter-spacing: 2px; transition: all 0.3s; box-shadow: 0 4px 15px rgba(255,100,0,0.3);
    }
    button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(255,100,0,0.5); }

    #hud {
      position: absolute; top: 10px; right: 10px; z-index: 5; font-size: 14px;
      background: linear-gradient(135deg, rgba(0,0,0,0.7), rgba(30,10,10,0.7));
      padding: 15px; border-radius: 10px; border: 1px solid rgba(255,100,0,0.3); min-width: 150px;
    }
    #hud div { margin: 5px 0; }
    .hud-label { color: #ff9944; display: inline-block; width: 80px; }
    .hud-value { color: #fff; font-weight: bold; }
    #thrustBar { width: 120px; height: 12px; background: #333; margin-top: 5px; border-radius: 6px; overflow: hidden; border: 1px solid #555; }
    #thrustFill { height: 100%; background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000); width: 0%; transition: width 0.1s; }
    .warning { color: #ff4444; animation: blink 0.5s infinite; }
    @keyframes blink { 50% { opacity: 0.3; } }

    #gameOverScreen h2 { color: #ff9944; margin: 10px 0; }
    .final-score { font-size: 36px; color: #00ff00; margin: 20px 0; }

    .difficulty-selector { margin: 20px 0; }
    .difficulty-btn { padding: 8px 20px; margin: 0 5px; font-size: 16px; background: rgba(255,100,0,0.2); border: 1px solid #ff6600; }
    .difficulty-btn.selected { background: #ff6600; }
      /* Landing quip banner */
    #quipBanner { position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); max-width:80vw; text-align:center;
      background: rgba(0,0,0,0.78); border:1px solid rgba(255,153,68,0.7); padding:14px 22px; border-radius:12px; z-index:12;
      font-size:26px; font-weight:800; line-height:1.25; letter-spacing:0.4px; text-shadow:0 2px 12px rgba(255,153,68,0.35);
      opacity:0; transition:opacity .25s ease; }
    #quipBanner.show { opacity:1; }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <div id="startScreen">
    <h1>üöÄ Mars Lander üöÄ</h1>
    <div class="instructions">
      <h3>Mission Briefing</h3>
      <p>Land your spacecraft safely on the red planet's surface. Find the landing pad and touch down gently!</p>
      <div class="controls">
        <span>‚Üë</span><span>Main Thruster</span>
        <span>‚Üê ‚Üí</span><span>Rotate</span>
        <span>A / D</span><span>Side Thrusters</span>
        <span>Esc</span><span>Pause</span>
      </div>
      <p style="margin-top: 15px; color: #ff9944;">‚ö†Ô∏è Watch your fuel and landing speed!</p>
    </div>
    <div class="difficulty-selector">
      <button class="difficulty-btn selected" data-diff="easy">Easy</button>
      <button class="difficulty-btn" data-diff="normal">Normal</button>
      <button class="difficulty-btn" data-diff="hard">Hard</button>
    </div>
    <button id="startButton">Launch Mission</button>
    <div style="margin-top: 20px;">
      <button id="musicToggle" style="padding: 8px 15px; font-size: 14px; background: rgba(255,100,0,0.3);">üéµ Music: ON</button>
    </div>
  </div>

  <audio id="bgMusic" loop preload="auto">
    <source src="https://raw.githubusercontent.com/barnacle1028/Mars-Launcher-2030/main/Galactic%20Pixels.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>

  <div id="gameOverScreen" style="display: none;">
    <h1>Game Over</h1>
    <h2 id="gameOverMessage" style="font-style: italic;">Keep Practicing!</h2>
    <div class="final-score">Final Score: <span id="finalScore">0</span></div>

    <div id="highScoreEntry" style="display: none; margin: 20px 0;">
      <h3 style="color: #00ff00;">NEW HIGH SCORE!</h3>
      <div style="display: flex; align-items: center; gap: 10px; justify-content: center;">
        <label style="color: #ff9944;">Enter Initials:</label>
        <input type="text" id="initialsInput" maxlength="3" style="width: 60px; padding: 5px; font-size: 20px; text-transform: uppercase; background: #222; color: white; border: 2px solid #ff6600; text-align: center;">
        <button id="saveScoreBtn" style="padding: 8px 15px; font-size: 16px;">Save</button>
      </div>
    </div>

    <div id="highScoresList" style="margin: 20px 0;">
      <h3 style="color: #ff9944; margin-bottom: 10px;">HIGH SCORES</h3>
      <div id="scoresTable" style="font-family: 'Courier New'; font-size: 18px; line-height: 1.8;"></div>
    </div>

    <button id="restartButton">Try Again</button>
  </div>

  <div id="hud">
    <div><span class="hud-label">Level:</span> <span id="level" class="hud-value" style="color: #ff9944;">1</span></div>
    <div><span class="hud-label">Fuel:</span> <span id="fuel" class="hud-value">100</span>%</div>
    <div id="thrustBar"><div id="thrustFill"></div></div>
    <div><span class="hud-label">Score:</span> <span id="score" class="hud-value">0</span></div>
    <div><span class="hud-label">Speed:</span> <span id="speed" class="hud-value">0</span></div>
    <div><span class="hud-label">Altitude:</span> <span id="altitude" class="hud-value">0</span>m</div>
    <div><span class="hud-label">Lives:</span> <span id="lives" class="hud-value">üöÄüöÄüöÄ</span></div>
    <div id="warningText" style="display: none;" class="warning">‚ö†Ô∏è LOW FUEL!</div>
  </div>

  <div id="quipBanner" style="display:none;"></div>

  <script>
    // ===================== Audio =====================
    let audioContext;
    let thrustOscillator = null;

    function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }
    }

    function playThrustSound() {
      if (!audioContext || thrustOscillator) return;
      thrustOscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      thrustOscillator.type = 'sawtooth';
      thrustOscillator.frequency.setValueAtTime(110, audioContext.currentTime);
      gainNode.gain.setValueAtTime(0.07, audioContext.currentTime);
      thrustOscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      thrustOscillator.start();
    }

    function stopThrustSound() {
      if (thrustOscillator) {
        try { thrustOscillator.stop(); } catch (e) {}
        thrustOscillator.disconnect();
        thrustOscillator = null;
      }
    }

    function playCrashSound() {
      if (!audioContext) return;
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.type = 'square';
      oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(40, audioContext.currentTime + 0.5);
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.5);
    }

    function playSuccessSound() {
      if (!audioContext) return;
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.type = 'sine';
      oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime);
      oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1);
      oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2);
      gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.3);
    }

    // ===================== Game State =====================
    let gameRunning = false;
    let paused = false;
    let difficulty = 'easy';
    let dpr = Math.max(1, window.devicePixelRatio || 1);

    // Physics units: px/s and px/s^2
    const DIFF = {
      easy:   { g: 18, fuel: 130, thrust: 130, side: 60, rot: 2.0, pads: 1, padW: [110, 150], landV: 45 },
      normal: { g: 24, fuel: 110, thrust: 130, side: 60, rot: 2.2, pads: 1, padW: [90, 130], landV: 40 },
      hard:   { g: 30, fuel: 100, thrust: 130, side: 55, rot: 2.4, pads: 1, padW: [70, 110], landV: 35 }
    };

    let highScores = [];

    function loadHighScores() {
      try {
        const stored = localStorage.getItem('marsLanderHighScores');
        if (stored) {
          highScores = JSON.parse(stored);
        } else {
          highScores = [
            { initials: 'ACE', score: 1000, level: 10 },
            { initials: 'PRO', score: 750, level: 8 },
            { initials: 'FLY', score: 500, level: 5 },
            { initials: 'JET', score: 250, level: 3 },
            { initials: 'NEW', score: 100, level: 1 }
          ];
          saveHighScores();
        }
      } catch (e) {
        highScores = [
          { initials: 'ACE', score: 1000, level: 10 },
          { initials: 'PRO', score: 750, level: 8 },
          { initials: 'FLY', score: 500, level: 5 },
          { initials: 'JET', score: 250, level: 3 },
          { initials: 'NEW', score: 100, level: 1 }
        ];
      }
    }
    function saveHighScores() { try { localStorage.setItem('marsLanderHighScores', JSON.stringify(highScores)); } catch (e) {} }
    function isHighScore(score) { return highScores.length < 5 || score > highScores[highScores.length - 1].score; }
    function addHighScore(initials, score, level) {
      highScores.push({ initials: initials.toUpperCase(), score, level });
      highScores.sort((a, b) => b.score - a.score);
      highScores = highScores.slice(0, 5);
      saveHighScores();
    }
    function displayHighScores() {
      const scoresTable = document.getElementById('scoresTable');
      scoresTable.innerHTML = highScores.map((s, index) => {
        const rank = index + 1;
        const medalEmoji = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : '  ';
        return `<div style="display: flex; justify-content: center; margin: 5px 0;">
          <span style="width: 40px; text-align: right; color: #ff9944;">${medalEmoji}</span>
          <span style="width: 60px; text-align: center; color: white;">${s.initials}</span>
          <span style="width: 100px; text-align: right; color: #00ff00;">${s.score}</span>
          <span style="width: 80px; text-align: right; color: #888;">Lvl ${s.level}</span>
        </div>`;
      }).join('');
    }

    loadHighScores();

    // ====== Landing Quips ======
    let lastInitials = '';
    try { lastInitials = (localStorage.getItem('marsLanderLastInitials') || '').toUpperCase(); } catch(e) {}

    const BASE_QUIPS = [
      "That's one small step for a rocket, one giant leap for my property values on Mars.",
      "Finally, a delivery address even more remote than rural Alaska.",
      "Great, now we need to update all those 'Men are from Mars' jokes.",
      "The ultimate work-from-home setup.",
      "Somewhere, a flat-Earther is having a very bad day.",
      "Mars just got its first bad neighbor.",
      "I bet the Wi-Fi still doesn't reach the bathroom.",
      "Congratulations on the solar system's most expensive Airbnb.",
      "At least now we know where to send all those extended warranty calls."
    ];

    function pickQuip() {
      const list = BASE_QUIPS.slice();
      if (lastInitials.includes('TED')) list.push("The Red Planet just became the Ted Planet.");
      return list[Math.floor(Math.random()*list.length)];
    }

    function showQuip(text, ms=1200) {
      const el = document.getElementById('quipBanner');
      if (!el) return;
      el.textContent = text;
      el.style.display = 'block';
      requestAnimationFrame(()=> el.classList.add('show'));
      setTimeout(()=>{ el.classList.remove('show'); el.style.display='none'; }, ms);
    }

    // ===== Lander sprite image (programmatic) =====
    let landerImgReady = false;
    const landerImg = new Image();

    function createRocketSprite() {
      const c = document.createElement('canvas');
      c.width = 40; c.height = 60; const cx = c.getContext('2d');
      cx.fillStyle = '#e6e6e6'; cx.fillRect(12, 15, 16, 35);
      cx.fillStyle = '#ff4444'; cx.beginPath(); cx.moveTo(20, 5); cx.lineTo(12, 20); cx.lineTo(28, 20); cx.closePath(); cx.fill();
      cx.fillStyle = '#cccccc'; cx.beginPath(); cx.moveTo(8, 40); cx.lineTo(12, 35); cx.lineTo(12, 45); cx.closePath(); cx.fill();
      cx.beginPath(); cx.moveTo(32, 40); cx.lineTo(28, 35); cx.lineTo(28, 45); cx.closePath(); cx.fill();
      cx.fillStyle = '#333333'; cx.fillRect(14, 50, 12, 8);
      cx.fillStyle = '#4499ff'; cx.beginPath(); cx.arc(20, 25, 4, 0, Math.PI * 2); cx.fill();
      cx.fillStyle = '#999999'; for (let i = 18; i <= 44; i += 6) { cx.fillRect(13, i, 2, 2); cx.fillRect(25, i, 2, 2); }
      return c.toDataURL();
    }
    landerImg.onload = ()=>{ landerImgReady = true; };
    landerImg.src = createRocketSprite();

    // ===================== Canvas Setup =====================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // === Background & Atmosphere ===
    let mountains = []; // array of layers, each: { pts:[{x,y}], color, drift }
    let bgTime = 0;     // seconds, for gentle parallax drift

    function buildMountains() {
      const w = canvas.width / dpr;
      const h = canvas.height / dpr;
      mountains = [];
      const layers = [
        { base: 0.48, amp: 24,  segments: 18, color: 'rgba(120,40,30,0.35)', drift: 4 },
        { base: 0.60, amp: 42,  segments: 22, color: 'rgba(150,55,40,0.45)', drift: 8 },
        { base: 0.70, amp: 64,  segments: 26, color: 'rgba(180,70,45,0.55)', drift: 14 }
      ];
      for (const L of layers) {
        const pts = [];
        const step = w / (L.segments - 1);
        let y = h * L.base;
        for (let i = 0; i < L.segments; i++) {
          const x = i * step;
          y += (Math.random() - 0.5) * L.amp;
          y = Math.min(h * (L.base + 0.15), Math.max(h * (L.base - 0.12), y));
          pts.push({ x, y });
        }
        for (let k = 0; k < 1; k++) {
          for (let i = 1; i < pts.length - 1; i++) {
            pts[i].y = (pts[i-1].y + pts[i].y + pts[i+1].y)/3;
          }
        }
        mountains.push({ pts, color: L.color, drift: L.drift });
      }
    }

    function drawBackground() {
      const w = canvas.width / dpr, h = canvas.height / dpr;
      const sky = ctx.createLinearGradient(0, 0, 0, h);
      sky.addColorStop(0, '#1a0c0c');
      sky.addColorStop(0.45, '#2b0e0e');
      sky.addColorStop(1, '#180606');
      ctx.fillStyle = sky; ctx.fillRect(0, 0, w, h);
      ctx.fillStyle = 'rgba(200,90,50,0.08)';
      ctx.fillRect(0, h*0.55, w, h*0.45);
      for (let i = 0; i < mountains.length; i++) {
        const L = mountains[i];
        const offset = (bgTime * L.drift) % (w / (L.pts.length - 1));
        ctx.save();
        ctx.translate(-offset, 0);
        ctx.beginPath();
        ctx.moveTo(L.pts[0].x, L.pts[0].y);
        for (let j = 1; j < L.pts.length; j++) ctx.lineTo(L.pts[j].x, L.pts[j].y);
        ctx.lineTo(w, h); ctx.lineTo(0, h); ctx.closePath();
        ctx.fillStyle = L.color; ctx.fill();
        ctx.restore();
      }
    }

    // === Dust Devils ===
    let dustDevils = []; // each: {x,y,height,radius,drift,parts:[{h,a}],phase}
    let boulders = [];
    let devilSpawnTimer = 0;

    function initDustDevils() {
      // Start with none; schedule a random arrival soon after level start
      dustDevils = [];
      devilSpawnTimer = 2 + Math.random()*4; // 2‚Äì6s
    }

    function spawnDustDevil() {
      const w = canvas.width / dpr;
      const fromLeft = Math.random() < 0.5;
      const gx = fromLeft ? 0 : w;
      const x = fromLeft ? -60 : w + 60; // spawn just off-screen
      const y = groundYAt(gx) - 4;
      const height = 180 + Math.random()*140; // larger column
      const radius = 26 + Math.random()*16;   // larger core
      const drift = (fromLeft ? 1 : -1) * (10 + Math.random()*12); // 10‚Äì22 px/s across screen
      const parts = [];
      const n = 42; // more particles for a beefier look
      for (let k = 0; k < n; k++) parts.push({ h: Math.random(), a: Math.random()*Math.PI*2 });
      dustDevils.push({ x, y, height, radius, drift, parts, phase: Math.random()*Math.PI*2 });
    }

    function updateDustDevils(dt) {
      const w = canvas.width / dpr;
      // Only ever show one devil; spawn randomly
      if (dustDevils.length === 0) {
        devilSpawnTimer -= dt;
        if (devilSpawnTimer <= 0) {
          spawnDustDevil();
          devilSpawnTimer = 8 + Math.random()*8; // next appearance after 8‚Äì16s
        }
        return;
      }
      const d = dustDevils[0];
      d.x += d.drift * dt;
      const cx = Math.max(0, Math.min(w, d.x));
      d.y = groundYAt(cx) - 4;
      d.phase += dt * 1.2;
      for (const p of d.parts) {
        p.h += dt * (0.20 + Math.random()*0.05);
        if (p.h > 1) p.h -= 1;
        p.a += dt * 2.0;
      }
      // remove once fully off-screen
      if (d.x < -80 || d.x > w + 80) {
        dustDevils = [];
      }
    }

    function drawDustDevils() {
      if (!dustDevils.length) return;
      ctx.save();
      for (const d of dustDevils) {
        for (const p of d.parts) {
          const swirl = Math.sin(p.a + p.h*6);
          const r = d.radius * (0.5 + p.h * 0.9); // inverted cone: narrower base, wider top
          const px = d.x + swirl * r;
          const py = d.y - p.h * d.height;
          ctx.globalAlpha = 0.18 + 0.28*(1 - p.h);
          ctx.fillStyle = '#c7845a';
          ctx.beginPath(); ctx.arc(px, py, 1.6 + (1-p.h)*1.6, 0, Math.PI*2); ctx.fill();
        }
        const grd = ctx.createRadialGradient(d.x, d.y, 0, d.x, d.y, d.radius*2.2);
        grd.addColorStop(0, 'rgba(180,100,70,0.22)');
        grd.addColorStop(1, 'rgba(180,100,70,0)');
        ctx.globalAlpha = 1;
        ctx.fillStyle = grd;
        ctx.beginPath(); ctx.arc(d.x, d.y, d.radius*2.2, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();
    }


    function resize() {
      const maxW = Math.min(window.innerWidth, 1100);
      const maxH = Math.min(window.innerHeight, 800);
      canvas.width = Math.floor(maxW * dpr);
      canvas.height = Math.floor(maxH * dpr);
      canvas.style.width = maxW + 'px';
      canvas.style.height = maxH + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      buildMountains();
      if (terrain.points.length) rebuildTerrainForNewSize();
      draw();
    }
    window.addEventListener('resize', resize);

    // ===================== Terrain =====================
    const terrain = { points: [], pads: [], baseline: 0 };

    function rebuildTerrainForNewSize() {
      const w = canvas.width / dpr;
      if (!terrain.points.length) return;
      const minX = terrain.points[0].x;
      const maxX = terrain.points[terrain.points.length - 1].x;
      const scaleX = w / (maxX - minX);
      terrain.points = terrain.points.map(p => ({ x: (p.x - minX) * scaleX, y: p.y }));
      terrain.pads.forEach(p => { p.x *= scaleX; });
    }

    function generateTerrain(level) {
      const w = canvas.width / dpr;
      const h = canvas.height / dpr;
      const amplitude = 70 + level * 10;
      const segments = 28;
      const step = w / (segments - 1);
      const baseY = h * 0.75; terrain.baseline = baseY;
      const pts = []; let y = baseY + (Math.random() * 40 - 20);
      for (let i = 0; i < segments; i++) {
        const x = i * step;
        y += (Math.random() - 0.5) * amplitude;
        y = Math.min(h * 0.92, Math.max(h * 0.5, y));
        pts.push({ x, y });
      }
      for (let k = 0; k < 2; k++) {
        for (let i = 1; i < pts.length - 1; i++) { pts[i].y = (pts[i-1].y + pts[i].y + pts[i+1].y) / 3; }
      }

      const padCount = 1; // exactly one pad per level
      const [minW, maxW] = DIFF[difficulty].padW;
      const pads = [];
      for (let p = 0; p < padCount; p++) {
        const padW = Math.max(50, Math.random() * (maxW - minW) + minW - level * 4);
        const idx = 2 + Math.floor(Math.random() * (pts.length - 4));
        const x1 = pts[idx].x; const yPad = pts[idx].y;
        const x2 = Math.min(x1 + padW, w - 10);
        for (let i = 0; i < pts.length; i++) { if (pts[i].x >= x1 && pts[i].x <= x2) pts[i].y = yPad; }
        pads.push({ x: x1, y: yPad, w: x2 - x1, score: Math.round(300 - (x2 - x1)) });
      }
      pads.sort((a,b)=>a.x-b.x);
      terrain.points = pts; terrain.pads = pads; initDustDevils();
      // Scatter boulders along the ground for visual variety
      boulders = [];
      const count = Math.max(3, Math.floor(w / 260));
      for (let i = 0; i < count; i++) {
        const rx = Math.random() * w;
        const ry = groundYAt(rx) - 3;
        boulders.push({ x: rx, y: ry, r: 3 + Math.random()*4 });
      }
    }

    function groundYAt(x) {
      const pts = terrain.points; if (!pts.length) return Infinity;
      for (let i = 0; i < pts.length - 1; i++) {
        const a = pts[i], b = pts[i + 1];
        if (x >= a.x && x <= b.x) { const t = (x - a.x) / (b.x - a.x); return a.y * (1 - t) + b.y * t; }
      }
      return pts[pts.length - 1].y;
    }

    function drawTerrain() {
      const w = canvas.width / dpr, h = canvas.height / dpr; const pts = terrain.points; if (!pts.length) return;
      // Ground body
      ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y); for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.lineTo(w, h); ctx.lineTo(0, h); ctx.closePath();
      const grd = ctx.createLinearGradient(0, terrain.baseline - 120, 0, h);
      grd.addColorStop(0, '#3a1512'); grd.addColorStop(1, '#1a0707');
      ctx.fillStyle = grd; ctx.fill();
      // Ridge highlight
      ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y); for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.strokeStyle = 'rgba(255,150,90,0.32)'; ctx.lineWidth = 1.8; ctx.stroke();
      // Landing pads
      for (const p of terrain.pads) { ctx.fillStyle = '#4a3a32'; ctx.fillRect(p.x, p.y - 4, p.w, 6); ctx.fillStyle = '#ff9944'; ctx.fillRect(p.x, p.y - 2, p.w, 2); }
      // Scatter boulders
      for (const b of boulders) {
        ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fillStyle = '#6b3b2e'; ctx.fill();
        ctx.beginPath(); ctx.arc(b.x - b.r*0.3, b.y - b.r*0.2, b.r*0.5, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(255,180,130,0.25)'; ctx.fill();
      }
    }

    // ===== Explosion / Crash FX =====
    function spawnExplosion(x, y) {
      const count = 42;
      explosion = { particles: [], timer: 1.0 };
      for (let i = 0; i < count; i++) {
        const a = Math.random() * Math.PI * 2;
        const s = 80 + Math.random() * 180; // speed px/s
        explosion.particles.push({
          x, y,
          vx: Math.cos(a) * s,
          vy: Math.sin(a) * s - 60, // slight upward bias
          life: 0.8 + Math.random() * 0.6
        });
      }
      respawnTimer = 1.1; // delay before respawn/game over
      shakeMag = 14;      // initial shake strength
    }

    function updateExplosion(dt) {
      if (!explosion) return;
      explosion.timer -= dt;
      for (const p of explosion.particles) {
        p.vy += 30 * dt; // light gravity on debris
        p.x += p.vx * dt; p.y += p.vy * dt;
        p.life -= dt;
      }
      explosion.particles = explosion.particles.filter(p => p.life > 0);
      if (explosion.timer <= 0 || explosion.particles.length === 0) explosion = null;
    }

    function drawExplosion() {
      if (!explosion) return;
      ctx.save();
      for (const p of explosion.particles) {
        const t = Math.max(0, Math.min(1, p.life));
        ctx.globalAlpha = Math.min(1, t + 0.2);
        ctx.fillStyle = t > 0.5 ? '#ffbf3b' : '#ff5122';
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2 + 1.5 * (1 - t), 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    // ===================== Lander =====================
    const lander = { x: 0, y: 0, vx: 0, vy: 0, angle: 0, fuel: 100, width: 32, height: 48, alive: true, landed: false };
    let level = 1; let score = 0; let lives = 3;

    // Crash/Explosion state
    let explosion = null; // {particles:[{x,y,vx,vy,life}], timer}
    let respawnTimer = 0; // seconds remaining before respawn/game over
    let shakeMag = 0;     // pixels of screen shake
    let successTimer = 0; // pause after successful landing
    let advanceAfterSuccess = false; // advance level when successTimer ends
    // Spin tracking (for spin bonus)
    let spinAccum = 0;      // total absolute radians rotated since spawn
    let lastAngle = 0;      // last frame angle for delta calc
    const SPIN_BONUS_PER_REV = 150; // points per full 360¬∞

    const keys = { up: false, left: false, right: false, sideL: false, sideR: false };

    function resetLander(spawnTop = true) {
      const w = canvas.width / dpr; const h = canvas.height / dpr;
      lander.x = w * (0.15 + Math.random() * 0.7);
      lander.y = spawnTop ? 60 : Math.min(groundYAt(lander.x) - 80, h * 0.25);
      lander.vx = (Math.random() - 0.5) * 6; // gentle
      lander.vy = 0;
      lander.angle = 0;
      lander.fuel = DIFF[difficulty].fuel;
      lander.alive = true; lander.landed = false;
      // reset spin tracking
      spinAccum = 0; lastAngle = lander.angle;
    }

    function startLevel() { generateTerrain(level); resetLander(true); updateHUD(true); }

    // ===================== Input =====================
    window.addEventListener('keydown', (e) => {
      if (e.code === 'ArrowUp') keys.up = true;
      if (e.code === 'ArrowLeft') keys.left = true;
      if (e.code === 'ArrowRight') keys.right = true;
      if (e.code === 'KeyA') keys.sideL = true;
      if (e.code === 'KeyD') keys.sideR = true;
      if (e.code === 'Escape') { if (gameRunning) togglePause(); }
    });
    window.addEventListener('keyup', (e) => {
      if (e.code === 'ArrowUp') keys.up = false;
      if (e.code === 'ArrowLeft') keys.left = false;
      if (e.code === 'ArrowRight') keys.right = false;
      if (e.code === 'KeyA') keys.sideL = false;
      if (e.code === 'KeyD') keys.sideR = false;
    });

    // ===================== Game Loop =====================
    let lastTime = 0;
    function loop(ts) {
      if (!gameRunning) return;
      requestAnimationFrame(loop);
      const dt = Math.min(0.033, (ts - lastTime) / 1000 || 0.016);
      lastTime = ts;
      if (paused) { draw(); return; }
      update(dt); draw();
    }

    function applyDustDevilForce(dt) {
      if (!dustDevils.length) return;
      const d = dustDevils[0];
      const topY = d.y - d.height;
      const ny = Math.max(topY, Math.min(d.y, lander.y)); // nearest point along column by Y
      const dx = lander.x - d.x;
      const dy = lander.y - ny;
      const dist = Math.hypot(dx, dy);
      const influence = d.radius * 5; // area of effect
      if (dist < influence) {
        const PUSH_K = 50; // px/s^2 at center
        const scale = 1 - dist / influence;
        const inv = dist > 0 ? 1/dist : 0;
        const ax = dx * inv * PUSH_K * scale;
        const ay = dy * inv * PUSH_K * scale * 0.6; // damp vertical push a bit
        lander.vx += ax * dt;
        lander.vy += ay * dt;
      }
    }

    function update(dt) {
      bgTime += dt; // for parallax drift
      updateDustDevils(dt);
      const cfg = DIFF[difficulty];

      // Crash animation / respawn timer
      if (respawnTimer > 0) {
        respawnTimer -= dt;
        updateExplosion(dt);
        shakeMag = Math.max(0, shakeMag - 60 * dt);
        if (respawnTimer <= 0) {
          if (lives <= 0) { gameOver(false); }
          else { resetLander(false); lander.alive = true; }
        }
        return; // hold physics until respawn
      }
      // Successful landing pause
      if (successTimer > 0) {
        successTimer -= dt;
        if (successTimer <= 0 && advanceAfterSuccess) {
          advanceAfterSuccess = false;
          level += 1; document.getElementById('level').textContent = level; startLevel();
        }
        return;
      }
      // rotation (radians/sec)
      if (keys.left)  lander.angle -= cfg.rot * dt;
      if (keys.right) lander.angle += cfg.rot * dt;

      // track spin amount for bonus (wrap-aware)
      {
        let dA = lander.angle - lastAngle;
        if (dA > Math.PI) dA -= Math.PI * 2;
        if (dA < -Math.PI) dA += Math.PI * 2;
        spinAccum += Math.abs(dA);
        lastAngle = lander.angle;
      }

      // main thrust along nose
      let throttle = 0;
      if (keys.up && lander.fuel > 0) {
        throttle = 1;
        const ax = Math.sin(lander.angle) * cfg.thrust; // px/s^2 ‚Äî push along the nose (right-turn + thrust -> rightward x)
        const ay = -Math.cos(lander.angle) * cfg.thrust; // px/s^2
        lander.vx += ax * dt;
        lander.vy += ay * dt;
        lander.fuel = Math.max(0, lander.fuel - 14 * dt);
        playThrustSound();
      } else {
        stopThrustSound();
      }

      // side thrusters (A/D)
      if (lander.fuel > 0) {
        if (keys.sideL) { lander.vx -= cfg.side * dt; lander.fuel = Math.max(0, lander.fuel - 8 * dt); }
        if (keys.sideR) { lander.vx += cfg.side * dt; lander.fuel = Math.max(0, lander.fuel - 8 * dt); }
      }

      // gravity
      lander.vy += cfg.g * dt;

      // dust devil influence (gentle push away if close)
      applyDustDevilForce(dt);

      // integrate
      lander.x += lander.vx * dt;
      lander.y += lander.vy * dt;

      // wrap X
      const w = canvas.width / dpr, h = canvas.height / dpr;
      if (lander.x < 0) lander.x += w; else if (lander.x > w) lander.x -= w;

      // collision with ground
      const gy = groundYAt(lander.x); const footY = lander.y + lander.height * 0.5;
      if (footY >= gy) {
        const onPad = terrain.pads.find(p => lander.x >= p.x && lander.x <= p.x + p.w);
        const speed = Math.hypot(lander.vx, lander.vy);
        const upright = Math.abs(lander.angle) < 0.2; // ~11¬∞
        const soft = speed <= DIFF[difficulty].landV;
        if (onPad && upright && soft) { handleLanding(onPad, speed); } else { handleCrash(); }
      }

      // HUD
      document.getElementById('speed').textContent = Math.round(Math.hypot(lander.vx, lander.vy));
      document.getElementById('fuel').textContent = Math.round(lander.fuel);
      document.getElementById('thrustFill').style.width = (throttle * 100) + '%';
      const alt = Math.max(0, Math.round(groundYAt(lander.x) - footY));
      document.getElementById('altitude').textContent = alt;
      document.getElementById('warningText').style.display = lander.fuel <= 15 ? 'block' : 'none';
    }

    function handleLanding(pad, speed) {
      playSuccessSound(); lander.landed = true;
      const precision = Math.max(100, 300 - Math.round(pad.w));
      const fuelBonus = Math.round(lander.fuel * 2);
      const softness = Math.max(0, Math.round((DIFF[difficulty].landV - speed) * 120));
      const spinRevs = Math.floor(spinAccum / (Math.PI * 2));
      const spinBonus = spinRevs * SPIN_BONUS_PER_REV;
      const gained = 100 + precision + fuelBonus + softness + Math.round(level * 15) + spinBonus;
      score += gained; document.getElementById('score').textContent = score;

      // celebratory quip + short pause before next level
      const quipText = pickQuip() + (spinRevs > 0 ? `  (+${spinBonus} spin bonus for ${spinRevs} rev${spinRevs>1?'s':''})` : '');
      showQuip(quipText, 2000);
      lander.vx = 0; lander.vy = 0;
      successTimer = 2.0; // seconds
      advanceAfterSuccess = true;
    }

    function handleCrash() {
      playCrashSound();
      lives -= 1; updateLivesHUD();
      lander.alive = false;
      spawnExplosion(lander.x, lander.y);
      // Delay respawn/game over; handled in update() after explosion
    }

    function updateLivesHUD() {
      const icons = ['','üöÄ','üöÄüöÄ','üöÄüöÄüöÄ'];
      document.getElementById('lives').textContent = icons[Math.max(0, Math.min(3, lives))];
    }

    function drawLander() {
      ctx.save(); ctx.translate(lander.x, lander.y); ctx.rotate(lander.angle);
      if (landerImgReady) { ctx.drawImage(landerImg, -20, -30, 40, 60); } else { ctx.fillStyle = '#ddd'; ctx.fillRect(-16, -20, 32, 40); }
      if (keys.up && lander.fuel > 0) { ctx.beginPath(); ctx.moveTo(-8, 30); ctx.lineTo(0, 30 + (8 + Math.random()*16)); ctx.lineTo(8, 30); ctx.closePath(); ctx.fillStyle='rgba(255,140,0,0.9)'; ctx.fill(); }
      if (keys.sideL && lander.fuel > 0) { ctx.beginPath(); ctx.moveTo(16, 10); ctx.lineTo(24, 10+Math.random()*8); ctx.lineTo(16, 14); ctx.fillStyle='rgba(255,120,0,0.8)'; ctx.fill(); }
      if (keys.sideR && lander.fuel > 0) { ctx.beginPath(); ctx.moveTo(-16, 10); ctx.lineTo(-24, 10+Math.random()*8); ctx.lineTo(-16, 14); ctx.fillStyle='rgba(255,120,0,0.8)'; ctx.fill(); }
      ctx.restore();
    }

    function draw() {
      const w = canvas.width / dpr, h = canvas.height / dpr;
      ctx.clearRect(0, 0, w, h);
      ctx.save();
      if (shakeMag > 0) ctx.translate((Math.random()-0.5)*shakeMag, (Math.random()-0.5)*shakeMag);
      drawBackground();
      drawTerrain();
      drawDustDevils();
      if (lander.alive) drawLander();
      if (explosion) drawExplosion();
      ctx.restore();
    }

    function updateHUD(reset=false) {
      if (reset) { document.getElementById('level').textContent = level; document.getElementById('score').textContent = score; updateLivesHUD(); }
      document.getElementById('fuel').textContent = Math.round(lander.fuel);
    }

    // ===================== UI / Screens =====================
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const startBtn = document.getElementById('startButton');
    const restartBtn = document.getElementById('restartButton');
    const diffBtns = [...document.querySelectorAll('.difficulty-btn')];

    diffBtns.forEach(btn => btn.addEventListener('click', () => {
      diffBtns.forEach(b => b.classList.remove('selected'));
      btn.classList.add('selected');
      difficulty = btn.dataset.diff;
    }));

    function beginGame() {
      initAudio();
      const music = document.getElementById('bgMusic');
      music.playbackRate = 0.7; // slower vibe
      music.play().catch(()=>{});
      gameRunning = true; paused = false; level = 1; score = 0; lives = 3;
      generateTerrain(level); resetLander(true); updateHUD(true);
      startScreen.style.display = 'none'; gameOverScreen.style.display = 'none';
      lastTime = performance.now(); requestAnimationFrame(loop);
    }

    function togglePause() { paused = !paused; if (!paused) lastTime = performance.now(); }

    function gameOver(won) {
      gameRunning = false; stopThrustSound();
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOverMessage').textContent = won ? 'Mission Complete!' : 'Keep Practicing!';
      const entry = document.getElementById('highScoreEntry'); entry.style.display = isHighScore(score) ? 'block' : 'none';
      displayHighScores(); gameOverScreen.style.display = 'flex';
    }

    startBtn.addEventListener('click', beginGame);
    restartBtn.addEventListener('click', beginGame);

    document.getElementById('saveScoreBtn').addEventListener('click', () => {
      const initials = (document.getElementById('initialsInput').value || 'YOU').slice(0,3);
      addHighScore(initials, score, level - 1);
      try { localStorage.setItem('marsLanderLastInitials', initials.toUpperCase()); lastInitials = initials.toUpperCase(); } catch(e) {}
      document.getElementById('highScoreEntry').style.display = 'none';
      displayHighScores();
    });

    // Music toggle on start screen
    const musicToggle = document.getElementById('musicToggle');
    const bgMusic = document.getElementById('bgMusic');
    musicToggle.addEventListener('click', async () => {
      if (!audioContext) initAudio();
      if (bgMusic.paused) {
        bgMusic.playbackRate = 0.7; // keep slowed tempo when resuming
        try { await bgMusic.play(); } catch(e) {}
        musicToggle.textContent = 'üéµ Music: ON';
      } else { bgMusic.pause(); musicToggle.textContent = 'üéµ Music: OFF'; }
    });

    // ===================== Boot =====================
    (function boot(){
      const maxW = Math.min(window.innerWidth, 1100);
      const maxH = Math.min(window.innerHeight, 800);
      canvas.width = Math.floor(maxW * dpr);
      canvas.height = Math.floor(maxH * dpr);
      canvas.style.width = maxW + 'px';
      canvas.style.height = maxH + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      buildMountains();
      draw();
    })();
  </script>
</body>
</html>
