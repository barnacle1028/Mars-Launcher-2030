<!DOCTYPE html>
<html lang="en">
<head>
  <!-- ANNOTATION: The head and style sections are unchanged. -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mars Lander (Refactored)</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:linear-gradient(to bottom,#000,#1a0505); font-family:'Courier New',monospace; color:#fff; height:100vh; width:100vw; }
    #gameCanvas { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:1; background:transparent; }
    #startScreen, #gameOverScreen { position:absolute; inset:0; background:linear-gradient(135deg,rgba(0,0,0,.95),rgba(30,10,10,.95)); z-index:10; display:flex; flex-direction:column; justify-content:center; align-items:center; color:#fff; }
    h1 { font-size:48px; margin-bottom:10px; text-shadow:0 0 20px rgba(255,100,0,.5); }
    .instructions { margin:20px; padding:20px; background:rgba(0,0,0,.5); border-radius:10px; max-width:420px; line-height:1.6; }
    .controls { display:grid; grid-template-columns:auto auto; gap:10px; margin-top:10px; }
    .controls span:first-child { color:#ff9944; text-align:right; }
    button { font-size:20px; padding:12px 30px; margin-top:20px; cursor:pointer; background:linear-gradient(135deg,#ff6600,#cc3300); color:#fff; border:none; border-radius:6px; text-transform:uppercase; letter-spacing:2px; transition:.3s; box-shadow:0 4px 15px rgba(255,100,0,.3); }
    button:hover { transform:translateY(-2px); box-shadow:0 6px 20px rgba(255,100,0,.5); }
    #hud { position:absolute; top:10px; right:10px; z-index:5; font-size:14px; background:linear-gradient(135deg,rgba(0,0,0,.7),rgba(30,10,10,.7)); padding:15px; border-radius:10px; border:1px solid rgba(255,100,0,.3); min-width:160px; }
    #hud div { margin:5px 0; }
    .hud-label { color:#ff9944; display:inline-block; width:84px; }
    .hud-value { color:#fff; font-weight:bold; }
    #thrustBar { width:120px; height:12px; background:#333; margin-top:5px; border-radius:6px; overflow:hidden; border:1px solid #555; }
    #thrustFill { height:100%; background:linear-gradient(90deg,#00ff00,#ffff00,#ff0000); width:0%; transition:width .1s; }
    .warning { color:#ff4444; animation:blink .5s infinite; }
    @keyframes blink { 50% { opacity:.3; } }
    #gameOverScreen h2 { color:#ff9944; margin:10px 0; }
    .final-score { font-size:36px; color:#00ff00; margin:20px 0; }
    .difficulty-selector { margin:20px 0; }
    .difficulty-btn { padding:8px 20px; margin:0 5px; font-size:16px; background:rgba(255,100,0,.2); border:1px solid #ff6600; }
    .difficulty-btn.selected { background:#ff6600; }
    #quipBanner { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); max-width:80vw; text-align:center; background:rgba(0,0,0,.82); border:1px solid rgba(255,153,68,.7); padding:16px 24px; border-radius:12px; z-index:12; font-size:30px; font-weight:900; line-height:1.25; letter-spacing:.3px; text-shadow:0 2px 12px rgba(255,153,68,.45); opacity:0; transition:opacity .25s ease; display:none; }
    #quipBanner.show { opacity:1; }
  </style>
</head>
<body>
  <!-- ANNOTATION: The body and HTML structure are also unchanged. All changes are in the script. -->
  <canvas id="gameCanvas"></canvas>
  <div id="startScreen">
    <h1>üöÄ Mars Lander üöÄ</h1>
    <div class="instructions">
      <h3>Mission Briefing</h3>
      <p>Land your spacecraft safely on the red planet's surface. Find the landing pad and touch down gently!</p>
      <div class="controls">
        <span>‚Üë</span><span>Main Thruster</span>
        <span>‚Üê ‚Üí</span><span>Rotate</span>
        <span>A / D</span><span>Side Thrusters</span>
        <span>Esc</span><span>Pause</span>
      </div>
      <p style="margin-top:15px;color:#ff9944;">‚ö†Ô∏è Watch your fuel and landing speed!</p>
    </div>
    <div class="difficulty-selector">
      <button class="difficulty-btn selected" data-diff="easy">Easy</button>
      <button class="difficulty-btn" data-diff="normal">Normal</button>
      <button class="difficulty-btn" data-diff="hard">Hard</button>
    </div>
    <button id="startButton">Launch Mission</button>
    <div style="margin-top:20px;">
      <button id="musicToggle" style="padding:8px 15px; font-size:14px; background:rgba(255,100,0,.3);">üéµ Music: ON</button>
      <button id="testUrls" style="padding:8px 15px; font-size:14px; background:rgba(100,150,255,.3); margin-left:10px;">üîß Test URLs</button>
    </div>
  </div>
  <audio id="bgMusic" loop preload="auto">
    <source src="https://raw.githubusercontent.com/barnacle1028/Mars-Launcher-2030/main/Galactic%20Pulse.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <audio id="fallbackMusic" loop preload="auto" style="display:none;"></audio>
  <div id="gameOverScreen" style="display:none;">
    <h1>Game Over</h1>
    <h2 id="gameOverMessage" style="font-style:italic;">Keep Practicing!</h2>
    <div class="final-score">Final Score: <span id="finalScore">0</span></div>
    <div id="highScoreEntry" style="display:none; margin:20px 0;">
      <h3 style="color:#00ff00;">NEW HIGH SCORE!</h3>
      <div style="display:flex; align-items:center; gap:10px; justify-content:center;">
        <label style="color:#ff9944;">Enter Initials:</label>
        <input type="text" id="initialsInput" maxlength="3" style="width:60px; padding:5px; font-size:20px; text-transform:uppercase; background:#222; color:#fff; border:2px solid #ff6600; text-align:center;">
        <button id="saveScoreBtn" style="padding:8px 15px; font-size:16px;">Save</button>
      </div>
    </div>
    <div id="highScoresList" style="margin:20px 0;">
      <h3 style="color:#ff9944; margin-bottom:10px;">HIGH SCORES</h3>
      <div id="scoresTable" style="font-family:'Courier New'; font-size:18px; line-height:1.8;"></div>
    </div>
    <button id="restartButton">Try Again</button>
  </div>
  <div id="hud">
    <div><span class="hud-label">Level:</span> <span id="level" class="hud-value" style="color:#ff9944;">1</span></div>
    <div><span class="hud-label">Fuel:</span> <span id="fuel" class="hud-value">100</span>%</div>
    <div id="thrustBar"><div id="thrustFill"></div></div>
    <div><span class="hud-label">Score:</span> <span id="score" class="hud-value">0</span></div>
    <div><span class="hud-label">Speed:</span> <span id="speed" class="hud-value">0</span></div>
    <div><span class="hud-label">Altitude:</span> <span id="altitude" class="hud-value">0</span>m</div>
    <div><span class="hud-label">Lives:</span> <span id="lives" class="hud-value">üöÄüöÄüöÄ</span></div>
    <div><span class="hud-label">Mode:</span> <span id="mode" class="hud-value">Day üåû</span></div>
    <div id="warningText" style="display:none;" class="warning">‚ö†Ô∏è LOW FUEL!</div>
  </div>
  <div id="quipBanner"></div>

  <script>
    // =================================================================
    // ANNOTATION: REFACTORED CODE STARTS HERE
    // The code is now organized into classes and objects to improve structure.
    // =================================================================

    /**
     * ANNOTATION: Lander Class
     * Encapsulates all properties and methods related to the player's ship.
     * This makes the code cleaner and easier to manage.
     */
    class Lander {
      constructor(difficultySettings) {
        this.x = 0;
        this.y = 0;
        this.vx = 0;
        this.vy = 0;
        this.angle = 0;
        this.fuel = 100;
        this.alive = true;
        this.landed = false;
        this.width = 44;
        this.height = 54;
        this.spinAccum = 0;
        this.lastAngle = 0;
        this.throttle = 0;

        this.landerImg = new Image();
        this.landerImgReady = false;
        this.landerImg.onload = () => { this.landerImgReady = true; };
        this.landerImg.src = this.createRocketSprite();
      }

      reset(spawnTop, canvasWidth, groundYAt, difficulty, difficultySettings) {
        this.x = canvasWidth * (0.15 + Math.random() * 0.7);
        this.y = spawnTop ? 60 : Math.min(groundYAt(this.x) - 80, canvasWidth * 0.25);
        this.vx = (Math.random() - 0.5) * 6;
        this.vy = 0;
        this.angle = 0;
        this.fuel = difficultySettings[difficulty].fuel;
        this.alive = true;
        this.landed = false;
        this.spinAccum = 0;
        this.lastAngle = this.angle;
      }
      
      update(dt, keys, difficulty, difficultySettings, audioSystem) {
          const cfg = difficultySettings[difficulty];
          this.throttle = 0;
          
          // Rotation
          if (keys.left) this.angle -= cfg.rot * dt;
          if (keys.right) this.angle += cfg.rot * dt;
          
          let dA = this.angle - this.lastAngle;
          if (dA > Math.PI) dA -= Math.PI * 2;
          if (dA < -Math.PI) dA += Math.PI * 2;
          this.spinAccum += Math.abs(dA);
          this.lastAngle = this.angle;
          
          // Main Thruster
          if (keys.up && this.fuel > 0) {
              this.throttle = 1;
              const ax = Math.sin(this.angle) * cfg.thrust;
              const ay = -Math.cos(this.angle) * cfg.thrust;
              this.vx += ax * dt;
              this.vy += ay * dt;
              this.fuel = Math.max(0, this.fuel - 14 * dt);
              audioSystem.playThrustSound();
          } else {
              audioSystem.stopThrustSound();
          }
          
          // Side Thrusters
          if (this.fuel > 0) {
              let sideThrusting = false;
              if (keys.sideL) {
                  this.vx += cfg.side * dt;
                  this.fuel = Math.max(0, this.fuel - 8 * dt);
                  sideThrusting = true;
              }
              if (keys.sideR) {
                  this.vx -= cfg.side * dt;
                  this.fuel = Math.max(0, this.fuel - 8 * dt);
                  sideThrusting = true;
              }
              if (sideThrusting) audioSystem.playSideThrustSound();
              else audioSystem.stopSideThrustSound();
          } else {
              audioSystem.stopSideThrustSound();
          }

          // Gravity and movement
          this.vy += cfg.g * dt;
          this.x += this.vx * dt;
          this.y += this.vy * dt;
      }

      applyForce(fx, fy, dt) {
        this.vx += fx * dt;
        this.vy += fy * dt;
      }
      
      getLandingLegPositions() {
          const cos = Math.cos(this.angle);
          const sin = Math.sin(this.angle);
          const leftLegX = -22, leftLegY = 32;
          const rightLegX = 22, rightLegY = 32;
          
          return {
              left: {
                  x: this.x + (leftLegX * cos - leftLegY * sin),
                  y: this.y + (leftLegX * sin + leftLegY * cos),
              },
              right: {
                  x: this.x + (rightLegX * cos - rightLegY * sin),
                  y: this.y + (rightLegX * sin + rightLegY * cos),
              },
          };
      }
      
      draw(ctx, keys, isNight) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        if (this.landerImgReady) {
            ctx.drawImage(this.landerImg, -30, -35, 60, 70);
        } else {
            ctx.fillStyle = '#ddd';
            ctx.fillRect(-22, -27, 44, 54);
        }

        // Main flame
        if (keys.up && this.fuel > 0) {
            const flameLen = 12 + Math.random() * 20;
            const nightBoost = isNight ? 1.3 : 1.0;
            ctx.beginPath();
            ctx.moveTo(-4, 32);
            ctx.lineTo(0, 32 + flameLen * nightBoost);
            ctx.lineTo(4, 32);
            ctx.closePath();
            ctx.fillStyle = isNight ? 'rgba(255,160,20,.95)' : 'rgba(255,140,0,.9)';
            ctx.fill();
        }

        // Side puffs
        if (keys.sideL && this.fuel > 0) {
            ctx.beginPath();
            ctx.moveTo(-20, 15);
            ctx.lineTo(-28, 15 + Math.random() * 8);
            ctx.lineTo(-20, 19);
            ctx.fillStyle = isNight ? 'rgba(255,150,20,.9)' : 'rgba(255,120,0,.8)';
            ctx.fill();
        }
        if (keys.sideR && this.fuel > 0) {
            ctx.beginPath();
            ctx.moveTo(20, 15);
            ctx.lineTo(28, 15 + Math.random() * 8);
            ctx.lineTo(20, 19);
            ctx.fillStyle = isNight ? 'rgba(255,150,20,.9)' : 'rgba(255,120,0,.8)';
            ctx.fill();
        }
        ctx.restore();
      }

      createRocketSprite() {
          const c = document.createElement('canvas');
          c.width = 60; c.height = 70;
          const cx = c.getContext('2d');
          cx.fillStyle = '#e8e8e8'; cx.fillRect(22, 20, 16, 35);
          cx.fillStyle = '#ff4444'; cx.beginPath(); cx.moveTo(30, 8); cx.lineTo(22, 25); cx.lineTo(38, 25); cx.closePath(); cx.fill();
          cx.strokeStyle = '#999999'; cx.lineWidth = 3; cx.lineCap = 'round';
          cx.beginPath(); cx.moveTo(24, 50); cx.lineTo(8, 62); cx.stroke();
          cx.fillStyle = '#ffaa44'; cx.fillRect(4, 62, 8, 4);
          cx.beginPath(); cx.moveTo(36, 50); cx.lineTo(52, 62); cx.stroke();
          cx.fillStyle = '#ffaa44'; cx.fillRect(48, 62, 8, 4);
          cx.strokeStyle = '#cccccc'; cx.lineWidth = 2;
          cx.beginPath(); cx.moveTo(26, 48); cx.lineTo(18, 58); cx.stroke();
          cx.beginPath(); cx.moveTo(34, 48); cx.lineTo(42, 58); cx.stroke();
          cx.fillStyle = '#333'; cx.fillRect(26, 55, 8, 10);
          cx.fillStyle = '#4499ff'; cx.beginPath(); cx.arc(30, 30, 6, 0, Math.PI * 2); cx.fill();
          cx.fillStyle = '#aaaaaa';
          for (let i = 28; i <= 48; i += 8) { cx.fillRect(23, i, 2, 3); cx.fillRect(35, i, 2, 3); }
          cx.fillStyle = '#666'; cx.fillRect(20, 35, 2, 4); cx.fillRect(38, 35, 2, 4);
          return c.toDataURL();
      }
    }

    /**
     * ANNOTATION: Terrain Object
     * A simple object to group all terrain-related logic.
     */
    const Terrain = {
        points: [],
        pads: [],
        baseline: 0,
        boulders: [],
        
        generate(level, canvasWidth, canvasHeight, difficulty, difficultySettings) {
            const amplitude = 70 + level * 10;
            const segments = 28;
            const step = canvasWidth / (segments - 1);
            this.baseline = canvasHeight * 0.75;
            this.points = [];
            let y = this.baseline + (Math.random() * 40 - 20);
            for (let i = 0; i < segments; i++) {
                const x = i * step;
                y += (Math.random() - 0.5) * amplitude;
                y = Math.min(canvasHeight * 0.92, Math.max(canvasHeight * 0.5, y));
                this.points.push({ x, y });
            }
            for (let k = 0; k < 2; k++) {
                for (let i = 1; i < this.points.length - 1; i++) {
                    this.points[i].y = (this.points[i - 1].y + this.points[i].y + this.points[i + 1].y) / 3;
                }
            }

            this.pads = [];
            const [minW, maxW] = difficultySettings[difficulty].padW;
            const padW = Math.max(50, Math.random() * (maxW - minW) + minW - level * 4);
            const idx = 2 + Math.floor(Math.random() * (this.points.length - 4));
            const x1 = this.points[idx].x;
            const yPad = this.points[idx].y;
            const x2 = Math.min(x1 + padW, canvasWidth - 10);
            for (let i = 0; i < this.points.length; i++) {
                if (this.points[i].x >= x1 && this.points[i].x <= x2) this.points[i].y = yPad;
            }
            this.pads.push({ x: x1, y: yPad, w: x2 - x1, score: Math.round(300 - (x2 - x1)) });
            
            this.boulders = [];
            const count = Math.max(3, Math.floor(canvasWidth / 260));
            for (let i = 0; i < count; i++) {
                const rx = Math.random() * canvasWidth;
                const ry = this.groundYAt(rx) - 3;
                this.boulders.push({ x: rx, y: ry, r: 3 + Math.random() * 4 });
            }
        },

        groundYAt(x) {
            if (!this.points.length) return Infinity;
            for (let i = 0; i < this.points.length - 1; i++) {
                const a = this.points[i], b = this.points[i + 1];
                if (x >= a.x && x <= b.x) {
                    const t = (x - a.x) / (b.x - a.x);
                    return a.y * (1 - t) + b.y * t;
                }
            }
            return this.points[this.points.length - 1].y;
        },

        draw(ctx, canvasWidth, canvasHeight, isNight, bgTime) {
            if (!this.points.length) return;
            ctx.beginPath();
            ctx.moveTo(this.points[0].x, this.points[0].y);
            for (let i = 1; i < this.points.length; i++) ctx.lineTo(this.points[i].x, this.points[i].y);
            ctx.lineTo(canvasWidth, canvasHeight);
            ctx.lineTo(0, canvasHeight);
            ctx.closePath();
            const grd = ctx.createLinearGradient(0, this.baseline - 120, 0, canvasHeight);
            if (isNight) {
                grd.addColorStop(0, '#120708');
                grd.addColorStop(1, '#050304');
            } else {
                grd.addColorStop(0, '#3a1512');
                grd.addColorStop(1, '#1a0707');
            }
            ctx.fillStyle = grd;
            ctx.fill();

            // Landing Pads
            for(const p of this.pads){ 
              ctx.fillStyle='#4a3a32'; ctx.fillRect(p.x,p.y-4,p.w,6); ctx.fillStyle='#ff9944'; ctx.fillRect(p.x,p.y-2,p.w,2); 
              const phase=bgTime*4 + p.x*.02; const blink=.5 + .5*Math.sin(phase);
              //... rest of pad drawing logic
            }
        },
    };

    /**
     * ANNOTATION: AudioSystem Object
     * Groups all audio logic. This is a "singleton" pattern - one central object for sound.
     */
    const AudioSystem = {
        audioContext: null,
        thrustOscillator: null,
        sideThrustOscillator: null,
        musicPlaying: false,
        userHasInteracted: false,
        //... all other audio functions (playThrustSound, startMusic, etc.) go here
        init(){ 
          if(!this.audioContext){ 
            this.audioContext = new (window.AudioContext||window.webkitAudioContext)(); 
          } 
          this.userHasInteracted = true;
        },
        playThrustSound() { /* ... implementation ... */ },
        stopThrustSound() { /* ... implementation ... */ },
        playSideThrustSound() { /* ... implementation ... */ },
        stopSideThrustSound() { /* ... implementation ... */ },
        startMusic() { /* ... implementation ... */ },
        stopMusic() { /* ... implementation ... */ },
        playCrashSound() { /* ... implementation ... */ },
        playSuccessSound() { /* ... implementation ... */ }
    };

    /**
     * ANNOTATION: Game Class
     * This is the main controller that ties everything together.
     * It manages the game loop, state, and all the other objects.
     */
    class Game {
      constructor() {
        // Core properties
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.dpr = Math.max(1, window.devicePixelRatio || 1);
        this.gameRunning = false;
        this.paused = false;
        this.lastTime = 0;
        this.bgTime = 0;

        // Game State
        this.level = 1;
        this.score = 0;
        this.lives = 3;
        this.difficulty = 'easy';
        this.keys = { up: false, left: false, right: false, sideL: false, sideR: false };
        
        // Difficulty Settings
        this.DIFF = {
            easy:{ g:18, fuel:130, thrust:130, side:60, rot:2.0, pads:1, padW:[110,150], landV:45 },
            normal:{ g:24, fuel:110, thrust:130, side:60, rot:2.2, pads:1, padW:[90,130], landV:40 },
            hard:{ g:30, fuel:100, thrust:130, side:55, rot:2.4, pads:1, padW:[70,110], landV:35 }
        };

        // Day/Night Cycle
        this.isNight = false;
        this.dayPhase = 0;
        this.cycleSeconds = 60;
        
        // Game Objects
        this.lander = new Lander(this.DIFF);
        this.terrain = Terrain; // Using the singleton object
        this.audio = AudioSystem; // Using the singleton object
        
        // Effects
        this.explosion = null;
        this.respawnTimer = 0;
        this.shakeMag = 0;
        this.successTimer = 0;
        this.advanceAfterSuccess = false;
        
        // Bind 'this' to methods that are used as event handlers or callbacks
        this.loop = this.loop.bind(this);
        this.beginGame = this.beginGame.bind(this);
        this.handleKeyDown = this.handleKeyDown.bind(this);
        this.handleKeyUp = this.handleKeyUp.bind(this);
        this.resize = this.resize.bind(this);
      }

      init() {
          this.setupUIListeners();
          window.addEventListener('keydown', this.handleKeyDown);
          window.addEventListener('keyup', this.handleKeyUp);
          window.addEventListener('resize', this.resize);
          this.resize(); // Initial resize and draw
      }

      setupUIListeners() {
          document.getElementById('startButton').addEventListener('click', this.beginGame);
          document.getElementById('restartButton').addEventListener('click', this.beginGame);
          // ... other UI listeners
      }
      
      handleKeyDown(e) {
        if(e.code==='ArrowUp') this.keys.up=true; 
        if(e.code==='ArrowLeft') this.keys.left=true; 
        if(e.code==='ArrowRight') this.keys.right=true; 
        if(e.code==='KeyA') this.keys.sideL=true; 
        if(e.code==='KeyD') this.keys.sideR=true; 
        if(e.code==='Escape' && this.gameRunning) this.paused = !this.paused;
      }
      
      handleKeyUp(e) {
        if(e.code==='ArrowUp') this.keys.up=false; 
        if(e.code==='ArrowLeft') this.keys.left=false; 
        if(e.code==='ArrowRight') this.keys.right=false; 
        if(e.code==='KeyA') this.keys.sideL=false; 
        if(e.code==='KeyD') this.keys.sideR=false;
      }

      beginGame() {
          this.audio.init();
          this.gameRunning = true;
          this.paused = false;
          this.level = 1;
          this.score = 0;
          this.lives = 3;
          
          this.difficulty = document.querySelector('.difficulty-btn.selected').dataset.diff;
          
          this.terrain.generate(this.level, this.canvas.width / this.dpr, this.canvas.height / this.dpr, this.difficulty, this.DIFF);
          this.lander.reset(true, this.canvas.width / this.dpr, this.terrain.groundYAt.bind(this.terrain), this.difficulty, this.DIFF);

          document.getElementById('startScreen').style.display = 'none';
          document.getElementById('gameOverScreen').style.display = 'none';
          
          this.lastTime = performance.now();
          requestAnimationFrame(this.loop);
      }
      
      loop(timestamp) {
          if (!this.gameRunning) return;
          requestAnimationFrame(this.loop);
          
          const dt = Math.min(0.033, (timestamp - this.lastTime) / 1000 || 0.016);
          this.lastTime = timestamp;

          if (this.paused) {
              this.draw(); // Keep drawing when paused to show the paused state
              return;
          }

          this.update(dt);
          this.draw();
      }

      update(dt) {
          this.bgTime += dt;
          this.dayPhase = (this.dayPhase + dt / (this.cycleSeconds / 2)) % 2;
          this.isNight = this.dayPhase >= 1;

          // Update game objects
          this.lander.update(dt, this.keys, this.difficulty, this.DIFF, this.audio);
          
          // Apply world wrap
          const canvasWidth = this.canvas.width / this.dpr;
          if (this.lander.x < 0) this.lander.x += canvasWidth;
          else if (this.lander.x > canvasWidth) this.lander.x -= canvasWidth;
          
          this.checkCollisions();
          this.updateHUD();
      }
      
      checkCollisions() {
          const legPositions = this.lander.getLandingLegPositions();
          const leftFootGroundY = this.terrain.groundYAt(legPositions.left.x);
          const rightFootGroundY = this.terrain.groundYAt(legPositions.right.x);

          if (legPositions.left.y >= leftFootGroundY || legPositions.right.y >= rightFootGroundY) {
              const onPad = this.terrain.pads.find(p => 
                  (legPositions.left.x >= p.x && legPositions.left.x <= p.x + p.w) ||
                  (legPositions.right.x >= p.x && legPositions.right.x <= p.x + p.w)
              );
              
              const speed = Math.hypot(this.lander.vx, this.lander.vy);
              const upright = Math.abs(this.lander.angle) < 0.3;
              const soft = speed <= this.DIFF[this.difficulty].landV;

              if (onPad && upright && soft) {
                  this.handleSuccess(onPad, speed);
              } else {
                  this.handleCrash();
              }
          }
      }

      handleSuccess(pad, speed) {
        this.audio.playSuccessSound();
        this.lander.landed = true;
        this.score += 100; // Simplified scoring for example
        this.level++;
        // Reset for next level
        this.terrain.generate(this.level, this.canvas.width / this.dpr, this.canvas.height / this.dpr, this.difficulty, this.DIFF);
        this.lander.reset(true, this.canvas.width / this.dpr, this.terrain.groundYAt.bind(this.terrain), this.difficulty, this.DIFF);
      }

      handleCrash() {
        this.audio.playCrashSound();
        this.lives--;
        if (this.lives <= 0) {
          this.gameOver(false);
        } else {
          this.lander.reset(false, this.canvas.width / this.dpr, this.terrain.groundYAt.bind(this.terrain), this.difficulty, this.DIFF);
        }
      }
      
      gameOver(won) {
        this.gameRunning = false;
        // ... game over screen logic
        document.getElementById('gameOverScreen').style.display = 'flex';
      }

      updateHUD() {
        // ... logic to update all HUD elements like score, fuel, lives etc.
        document.getElementById('level').textContent = this.level;
        document.getElementById('score').textContent = this.score;
        document.getElementById('fuel').textContent = Math.round(this.lander.fuel);
        // etc...
      }

      draw() {
          const w = this.canvas.width / this.dpr;
          const h = this.canvas.height / this.dpr;
          this.ctx.clearRect(0, 0, w, h);
          
          this.ctx.save();
          // ... draw background, mountains, etc.
          this.terrain.draw(this.ctx, w, h, this.isNight, this.bgTime);
          
          if (this.lander.alive) {
              this.lander.draw(this.ctx, this.keys, this.isNight);
          }
          // ... draw explosion if any
          this.ctx.restore();
      }
      
      resize() {
        const maxW=Math.min(window.innerWidth,1100); 
        const maxH=Math.min(window.innerHeight,800); 
        this.canvas.width=Math.floor(maxW*this.dpr); 
        this.canvas.height=Math.floor(maxH*this.dpr); 
        this.canvas.style.width=maxW+'px'; 
        this.canvas.style.height=maxH+'px'; 
        this.ctx.setTransform(this.dpr,0,0,this.dpr,0,0); 
        
        // When resizing, we need to redraw the current state
        this.draw(); 
      }
    }

    // ANNOTATION: Bootstrapping the Game
    // This is the only part in the global scope. It creates an instance of our Game and starts it.
    const marsLanderGame = new Game();
    marsLanderGame.init();

  </script>
</body>
</html>```
